# World coordinates go from left to right, bottom to top
# and use one-based indexing.

sprite Main {
    let world-width = 64
    let world-height = 48
    let tiles = [] as List[Num]

    inline fn world-width -> Num {
        world-width
    }

    inline fn world-height -> Num {
        world-height
    }

    # This is not bounds-checked.
    inline fn index-for-tile-at(x x: Num, y y: Num) -> Num {
        (x - 1) * world-height + y
    }

    inline fn tile-at(x x: Num, y y: Num) -> Num {
        tiles.at(index-for-tile-at(x: x, y: y))
    }

    inline fn set-tile-at(x x: Num, y y: Num, to tile: Num) {
        tiles.replace(index: index-for-tile-at(x: x, y: y), with: tile)
    }

    fn create-world {
        let mean-ground-level = world-height / 2
        let y-variation = 6

        tiles.delete-all()
        repeat world-width * world-height {
            tiles.push(1)
        }
        for x world-width {
            let ground = random(within: y-variation, of: mean-ground-level)
            let dirt-depth = random(between: 1, and: 4)
            for y ground - dirt-depth - 1 {
                set-tile-at(x: x, y: y + 1, to: 4)
            }
            for y dirt-depth {
                set-tile-at(x: x, y: ground - y, to: 3)
            }
            set-tile-at(x: x, y: ground, to: 2)
            set-tile-at(x: x, y: 1, to: 5)
        }

        # TODO: place clusters instead of single tiles
        let ore-clusters = world-width * 0.5
        repeat ore-clusters {
            let x = random(between: 1, and: world-width)
            let y = random(between: 1, and: mean-ground-level)
            if tile-at(x: x, y: y) == 4 {
                set-tile-at(x: x, y: y, to: 7)
            }
        }
    }
}

inline fn random(within variation: Num, of mean: Num) -> Num {
    random(between: mean - variation, and: mean + variation)
}
