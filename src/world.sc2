# World coordinates go from left to right, bottom to top
# and use one-based indexing.

sprite Main {
    let world-width = 512
    let world-height = 128
    let tiles = [] as List[Num]

    inline fn world-width -> Num {
        world-width
    }

    inline fn world-height -> Num {
        world-height
    }

    # This is not bounds-checked.
    inline fn index-for-tile-at(x x: Num, y y: Num) -> Num {
        (x - 1) * world-height + y
    }

    inline fn tile-at(x x: Num, y y: Num) -> Num {
        tiles.at(index-for-tile-at(x: x, y: y))
    }

    inline fn set-tile-at(x x: Num, y y: Num, to tile: Num) {
        tiles.replace(index: index-for-tile-at(x: x, y: y), with: tile)
    }

    inline fn is-in-bounds(x x: Num, y y: Num) -> Bool {
        not((x < 1).or(x > world-width).or(y < 1).or(y > world-height))
    }

    fn create-world {
        let mean-ground-level = world-height / 2
        let y-variation = 6

        tiles.delete-all()
        repeat world-width * world-height {
            tiles.push(1)
        }
        for x world-width {
            let ground = random(within: y-variation, of: mean-ground-level)
            let dirt-depth = random(between: 1, and: 4)
            for y ground - dirt-depth - 1 {
                set-tile-at(x: x, y: y + 1, to: 4)
            }
            for y dirt-depth {
                set-tile-at(x: x, y: ground - y, to: 3)
            }
            set-tile-at(x: x, y: ground, to: 2)
            set-tile-at(x: x, y: 1, to: 5)
            if random(between: 0, and: 6) == 0 {
                set-tile-at(
                    x: x,
                    y: ground + 1,
                    to: random(between: 11, and: 12),
                )
            }
        }

        let ore-clusters = world-width * 0.5
        repeat ore-clusters {
            let kind = random(between: 7, and: 10)
            let x = random(between: 1, and: world-width)
            let y = random(between: 1, and: mean-ground-level)
            while is-in-bounds(x: x, y: y).and(tile-at(x: x, y: y) == 4) {
                set-tile-at(x: x, y: y, to: kind)
                &x = x + random(within: 2, of: 0)
                &y = y + random(within: 1, of: 0)
            }
        }
    }
}

inline fn random(within variation: Num, of mean: Num) -> Num {
    random(between: mean - variation, and: mean + variation)
}
